// This file is auto-generated by @hey-api/openapi-ts

import { type Options, googleGoogleLogin, googleGoogleCallback, loginLoginAccessToken, loginTestToken, usersReadUsers, usersCreateUser, usersDeleteUserMe, usersReadUserMe, usersUpdateUserMe, usersUpdatePasswordMe, usersRegisterUser, usersDeleteUser, usersReadUserById, usersUpdateUser, utilsTestEmail, utilsHealthCheck, privateCreateUser, projectsGetOwnProjects, projectsCreateProject, projectsDeleteProject, projectsGetDashboard, projectsDownloadProject, projectsGetProjectStatus, projectsGetLineItems, projectsGetSampleByIndex, projectsAssignTask, projectsConfirmLineItem } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { GoogleGoogleLoginData, GoogleGoogleCallbackData, LoginLoginAccessTokenData, LoginLoginAccessTokenError, LoginLoginAccessTokenResponse, LoginTestTokenData, LoginTestTokenResponse, UsersReadUsersData, UsersCreateUserData, UsersCreateUserError, UsersCreateUserResponse, UsersDeleteUserMeData, UsersDeleteUserMeResponse, UsersReadUserMeData, UsersUpdateUserMeData, UsersUpdateUserMeError, UsersUpdateUserMeResponse, UsersUpdatePasswordMeData, UsersUpdatePasswordMeError, UsersUpdatePasswordMeResponse, UsersRegisterUserData, UsersRegisterUserError, UsersRegisterUserResponse, UsersDeleteUserData, UsersDeleteUserError, UsersDeleteUserResponse, UsersReadUserByIdData, UsersUpdateUserData, UsersUpdateUserError, UsersUpdateUserResponse, UtilsTestEmailData, UtilsTestEmailError, UtilsTestEmailResponse, UtilsHealthCheckData, PrivateCreateUserData, PrivateCreateUserError, PrivateCreateUserResponse, ProjectsGetOwnProjectsData, ProjectsCreateProjectData, ProjectsCreateProjectError, ProjectsCreateProjectResponse, ProjectsDeleteProjectData, ProjectsDeleteProjectError, ProjectsDeleteProjectResponse, ProjectsGetDashboardData, ProjectsDownloadProjectData, ProjectsDownloadProjectError, ProjectsDownloadProjectResponse, ProjectsGetProjectStatusData, ProjectsGetLineItemsData, ProjectsGetLineItemsError, ProjectsGetLineItemsResponse, ProjectsGetSampleByIndexData, ProjectsAssignTaskData, ProjectsAssignTaskError, ProjectsAssignTaskResponse, ProjectsConfirmLineItemData, ProjectsConfirmLineItemError, ProjectsConfirmLineItemResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const googleGoogleLoginQueryKey = (options?: Options<GoogleGoogleLoginData>) => createQueryKey('googleGoogleLogin', options);

/**
 * Google Login
 * Initiate Google OAuth login flow with CSRF protection
 */
export const googleGoogleLoginOptions = (options?: Options<GoogleGoogleLoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await googleGoogleLogin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: googleGoogleLoginQueryKey(options)
    });
};

export const googleGoogleCallbackQueryKey = (options?: Options<GoogleGoogleCallbackData>) => createQueryKey('googleGoogleCallback', options);

/**
 * Google Callback
 * Handle Google OAuth callback with enhanced security validation
 */
export const googleGoogleCallbackOptions = (options?: Options<GoogleGoogleCallbackData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await googleGoogleCallback({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: googleGoogleCallbackQueryKey(options)
    });
};

export const loginLoginAccessTokenQueryKey = (options: Options<LoginLoginAccessTokenData>) => createQueryKey('loginLoginAccessToken', options);

/**
 * Login Access Token
 * OAuth2 compatible token login, get an access token for future requests
 */
export const loginLoginAccessTokenOptions = (options: Options<LoginLoginAccessTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await loginLoginAccessToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginLoginAccessTokenQueryKey(options)
    });
};

/**
 * Login Access Token
 * OAuth2 compatible token login, get an access token for future requests
 */
export const loginLoginAccessTokenMutation = (options?: Partial<Options<LoginLoginAccessTokenData>>): UseMutationOptions<LoginLoginAccessTokenResponse, LoginLoginAccessTokenError, Options<LoginLoginAccessTokenData>> => {
    const mutationOptions: UseMutationOptions<LoginLoginAccessTokenResponse, LoginLoginAccessTokenError, Options<LoginLoginAccessTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await loginLoginAccessToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginTestTokenQueryKey = (options?: Options<LoginTestTokenData>) => createQueryKey('loginTestToken', options);

/**
 * Test Token
 * Test access token
 */
export const loginTestTokenOptions = (options?: Options<LoginTestTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await loginTestToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginTestTokenQueryKey(options)
    });
};

/**
 * Test Token
 * Test access token
 */
export const loginTestTokenMutation = (options?: Partial<Options<LoginTestTokenData>>): UseMutationOptions<LoginTestTokenResponse, DefaultError, Options<LoginTestTokenData>> => {
    const mutationOptions: UseMutationOptions<LoginTestTokenResponse, DefaultError, Options<LoginTestTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await loginTestToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUsersQueryKey = (options?: Options<UsersReadUsersData>) => createQueryKey('usersReadUsers', options);

/**
 * Read Users
 * Retrieve users.
 */
export const usersReadUsersOptions = (options?: Options<UsersReadUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersReadUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersReadUsersQueryKey(options)
    });
};

export const usersCreateUserQueryKey = (options: Options<UsersCreateUserData>) => createQueryKey('usersCreateUser', options);

/**
 * Create User
 * Create new user.
 */
export const usersCreateUserOptions = (options: Options<UsersCreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersCreateUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersCreateUserQueryKey(options)
    });
};

/**
 * Create User
 * Create new user.
 */
export const usersCreateUserMutation = (options?: Partial<Options<UsersCreateUserData>>): UseMutationOptions<UsersCreateUserResponse, UsersCreateUserError, Options<UsersCreateUserData>> => {
    const mutationOptions: UseMutationOptions<UsersCreateUserResponse, UsersCreateUserError, Options<UsersCreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersCreateUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User Me
 * Delete own user.
 */
export const usersDeleteUserMeMutation = (options?: Partial<Options<UsersDeleteUserMeData>>): UseMutationOptions<UsersDeleteUserMeResponse, DefaultError, Options<UsersDeleteUserMeData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteUserMeResponse, DefaultError, Options<UsersDeleteUserMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersDeleteUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUserMeQueryKey = (options?: Options<UsersReadUserMeData>) => createQueryKey('usersReadUserMe', options);

/**
 * Read User Me
 * Get current user.
 */
export const usersReadUserMeOptions = (options?: Options<UsersReadUserMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersReadUserMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersReadUserMeQueryKey(options)
    });
};

/**
 * Update User Me
 * Update own user.
 */
export const usersUpdateUserMeMutation = (options?: Partial<Options<UsersUpdateUserMeData>>): UseMutationOptions<UsersUpdateUserMeResponse, UsersUpdateUserMeError, Options<UsersUpdateUserMeData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateUserMeResponse, UsersUpdateUserMeError, Options<UsersUpdateUserMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersUpdateUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Password Me
 * Update own password.
 */
export const usersUpdatePasswordMeMutation = (options?: Partial<Options<UsersUpdatePasswordMeData>>): UseMutationOptions<UsersUpdatePasswordMeResponse, UsersUpdatePasswordMeError, Options<UsersUpdatePasswordMeData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdatePasswordMeResponse, UsersUpdatePasswordMeError, Options<UsersUpdatePasswordMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersUpdatePasswordMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersRegisterUserQueryKey = (options: Options<UsersRegisterUserData>) => createQueryKey('usersRegisterUser', options);

/**
 * Register User
 * Create new user without the need to be logged in.
 */
export const usersRegisterUserOptions = (options: Options<UsersRegisterUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersRegisterUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersRegisterUserQueryKey(options)
    });
};

/**
 * Register User
 * Create new user without the need to be logged in.
 */
export const usersRegisterUserMutation = (options?: Partial<Options<UsersRegisterUserData>>): UseMutationOptions<UsersRegisterUserResponse, UsersRegisterUserError, Options<UsersRegisterUserData>> => {
    const mutationOptions: UseMutationOptions<UsersRegisterUserResponse, UsersRegisterUserError, Options<UsersRegisterUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersRegisterUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 * Delete a user.
 */
export const usersDeleteUserMutation = (options?: Partial<Options<UsersDeleteUserData>>): UseMutationOptions<UsersDeleteUserResponse, UsersDeleteUserError, Options<UsersDeleteUserData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteUserResponse, UsersDeleteUserError, Options<UsersDeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersDeleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersReadUserByIdQueryKey = (options: Options<UsersReadUserByIdData>) => createQueryKey('usersReadUserById', options);

/**
 * Read User By Id
 * Get a specific user by id.
 */
export const usersReadUserByIdOptions = (options: Options<UsersReadUserByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersReadUserById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersReadUserByIdQueryKey(options)
    });
};

/**
 * Update User
 * Update a user.
 */
export const usersUpdateUserMutation = (options?: Partial<Options<UsersUpdateUserData>>): UseMutationOptions<UsersUpdateUserResponse, UsersUpdateUserError, Options<UsersUpdateUserData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateUserResponse, UsersUpdateUserError, Options<UsersUpdateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersUpdateUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const utilsTestEmailQueryKey = (options: Options<UtilsTestEmailData>) => createQueryKey('utilsTestEmail', options);

/**
 * Test Email
 * Test emails.
 */
export const utilsTestEmailOptions = (options: Options<UtilsTestEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await utilsTestEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: utilsTestEmailQueryKey(options)
    });
};

/**
 * Test Email
 * Test emails.
 */
export const utilsTestEmailMutation = (options?: Partial<Options<UtilsTestEmailData>>): UseMutationOptions<UtilsTestEmailResponse, UtilsTestEmailError, Options<UtilsTestEmailData>> => {
    const mutationOptions: UseMutationOptions<UtilsTestEmailResponse, UtilsTestEmailError, Options<UtilsTestEmailData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await utilsTestEmail({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const utilsHealthCheckQueryKey = (options?: Options<UtilsHealthCheckData>) => createQueryKey('utilsHealthCheck', options);

/**
 * Health Check
 */
export const utilsHealthCheckOptions = (options?: Options<UtilsHealthCheckData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await utilsHealthCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: utilsHealthCheckQueryKey(options)
    });
};

export const privateCreateUserQueryKey = (options: Options<PrivateCreateUserData>) => createQueryKey('privateCreateUser', options);

/**
 * Create User
 * Create a new user.
 */
export const privateCreateUserOptions = (options: Options<PrivateCreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await privateCreateUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: privateCreateUserQueryKey(options)
    });
};

/**
 * Create User
 * Create a new user.
 */
export const privateCreateUserMutation = (options?: Partial<Options<PrivateCreateUserData>>): UseMutationOptions<PrivateCreateUserResponse, PrivateCreateUserError, Options<PrivateCreateUserData>> => {
    const mutationOptions: UseMutationOptions<PrivateCreateUserResponse, PrivateCreateUserError, Options<PrivateCreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await privateCreateUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const projectsGetOwnProjectsQueryKey = (options?: Options<ProjectsGetOwnProjectsData>) => createQueryKey('projectsGetOwnProjects', options);

/**
 * Get Own Projects
 * Get projects owned by the current user.
 */
export const projectsGetOwnProjectsOptions = (options?: Options<ProjectsGetOwnProjectsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetOwnProjects({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsGetOwnProjectsQueryKey(options)
    });
};

export const projectsCreateProjectQueryKey = (options: Options<ProjectsCreateProjectData>) => createQueryKey('projectsCreateProject', options);

/**
 * Create Project
 * Create a new project.
 */
export const projectsCreateProjectOptions = (options: Options<ProjectsCreateProjectData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsCreateProject({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsCreateProjectQueryKey(options)
    });
};

/**
 * Create Project
 * Create a new project.
 */
export const projectsCreateProjectMutation = (options?: Partial<Options<ProjectsCreateProjectData>>): UseMutationOptions<ProjectsCreateProjectResponse, ProjectsCreateProjectError, Options<ProjectsCreateProjectData>> => {
    const mutationOptions: UseMutationOptions<ProjectsCreateProjectResponse, ProjectsCreateProjectError, Options<ProjectsCreateProjectData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsCreateProject({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Project
 * Delete a project by ID.
 */
export const projectsDeleteProjectMutation = (options?: Partial<Options<ProjectsDeleteProjectData>>): UseMutationOptions<ProjectsDeleteProjectResponse, ProjectsDeleteProjectError, Options<ProjectsDeleteProjectData>> => {
    const mutationOptions: UseMutationOptions<ProjectsDeleteProjectResponse, ProjectsDeleteProjectError, Options<ProjectsDeleteProjectData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsDeleteProject({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const projectsGetDashboardQueryKey = (options?: Options<ProjectsGetDashboardData>) => createQueryKey('projectsGetDashboard', options);

/**
 * Get Dashboard Data
 * Get dashboard statistics for all projects.
 */
export const projectsGetDashboardOptions = (options?: Options<ProjectsGetDashboardData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetDashboard({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsGetDashboardQueryKey(options)
    });
};

export const projectsDownloadProjectQueryKey = (options: Options<ProjectsDownloadProjectData>) => createQueryKey('projectsDownloadProject', options);

/**
 * Download Project
 * Download project data as JSONL file.
 */
export const projectsDownloadProjectOptions = (options: Options<ProjectsDownloadProjectData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsDownloadProject({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsDownloadProjectQueryKey(options)
    });
};

/**
 * Download Project
 * Download project data as JSONL file.
 */
export const projectsDownloadProjectMutation = (options?: Partial<Options<ProjectsDownloadProjectData>>): UseMutationOptions<ProjectsDownloadProjectResponse, ProjectsDownloadProjectError, Options<ProjectsDownloadProjectData>> => {
    const mutationOptions: UseMutationOptions<ProjectsDownloadProjectResponse, ProjectsDownloadProjectError, Options<ProjectsDownloadProjectData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsDownloadProject({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const projectsGetProjectStatusQueryKey = (options: Options<ProjectsGetProjectStatusData>) => createQueryKey('projectsGetProjectStatus', options);

/**
 * Get Project Status
 * Get the status of a specific project.
 */
export const projectsGetProjectStatusOptions = (options: Options<ProjectsGetProjectStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetProjectStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsGetProjectStatusQueryKey(options)
    });
};

export const projectsGetLineItemsQueryKey = (options: Options<ProjectsGetLineItemsData>) => createQueryKey('projectsGetLineItems', options);

/**
 * Get Line Items
 * Get line items from a project with pagination and filtering.
 */
export const projectsGetLineItemsOptions = (options: Options<ProjectsGetLineItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetLineItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsGetLineItemsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const projectsGetLineItemsInfiniteQueryKey = (options: Options<ProjectsGetLineItemsData>): QueryKey<Options<ProjectsGetLineItemsData>> => createQueryKey('projectsGetLineItems', options, true);

/**
 * Get Line Items
 * Get line items from a project with pagination and filtering.
 */
export const projectsGetLineItemsInfiniteOptions = (options: Options<ProjectsGetLineItemsData>) => {
    return infiniteQueryOptions<ProjectsGetLineItemsResponse, ProjectsGetLineItemsError, InfiniteData<ProjectsGetLineItemsResponse>, QueryKey<Options<ProjectsGetLineItemsData>>, number | Pick<QueryKey<Options<ProjectsGetLineItemsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ProjectsGetLineItemsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await projectsGetLineItems({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsGetLineItemsInfiniteQueryKey(options)
    });
};

export const projectsGetSampleByIndexQueryKey = (options: Options<ProjectsGetSampleByIndexData>) => createQueryKey('projectsGetSampleByIndex', options);

/**
 * Get Sample by Index
 * Get a specific sample by index from a project.
 */
export const projectsGetSampleByIndexOptions = (options: Options<ProjectsGetSampleByIndexData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsGetSampleByIndex({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsGetSampleByIndexQueryKey(options)
    });
};

export const projectsAssignTaskQueryKey = (options: Options<ProjectsAssignTaskData>) => createQueryKey('projectsAssignTask', options);

/**
 * Assign Task
 * Assign task to a user for a project.
 */
export const projectsAssignTaskOptions = (options: Options<ProjectsAssignTaskData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsAssignTask({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsAssignTaskQueryKey(options)
    });
};

/**
 * Assign Task
 * Assign task to a user for a project.
 */
export const projectsAssignTaskMutation = (options?: Partial<Options<ProjectsAssignTaskData>>): UseMutationOptions<ProjectsAssignTaskResponse, ProjectsAssignTaskError, Options<ProjectsAssignTaskData>> => {
    const mutationOptions: UseMutationOptions<ProjectsAssignTaskResponse, ProjectsAssignTaskError, Options<ProjectsAssignTaskData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsAssignTask({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const projectsConfirmLineItemQueryKey = (options: Options<ProjectsConfirmLineItemData>) => createQueryKey('projectsConfirmLineItem', options);

/**
 * Confirm Line Item
 * Confirm a line item with user feedback.
 */
export const projectsConfirmLineItemOptions = (options: Options<ProjectsConfirmLineItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await projectsConfirmLineItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: projectsConfirmLineItemQueryKey(options)
    });
};

/**
 * Confirm Line Item
 * Confirm a line item with user feedback.
 */
export const projectsConfirmLineItemMutation = (options?: Partial<Options<ProjectsConfirmLineItemData>>): UseMutationOptions<ProjectsConfirmLineItemResponse, ProjectsConfirmLineItemError, Options<ProjectsConfirmLineItemData>> => {
    const mutationOptions: UseMutationOptions<ProjectsConfirmLineItemResponse, ProjectsConfirmLineItemError, Options<ProjectsConfirmLineItemData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await projectsConfirmLineItem({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};